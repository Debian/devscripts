#!/usr/bin/python3
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# See file /usr/share/common-licenses/GPL-3 for more details.
#
"""
Apply a debdiff to a Debian source package.

It handles d/changelog hunks specially, to avoid conflicts.

Depends on dpkg-dev, devscripts, python3-unidiff, quilt.
"""

import argparse
import hashlib
import io
import logging
import os
import random
import unidiff
import shutil
import subprocess
import sys
import tempfile

dirname = os.path.dirname
basename = os.path.basename
C = subprocess.check_call

# this can be any valid value, it doesn't appear in the final output
DCH_DUMMY_TAIL = "\n -- debpatch dummy tool <infinity0@debian.org>  Thu, 01 Jan 1970 00:00:00 +0000\n\n"
TRY_ENCODINGS = ["utf-8", "latin-1"]
DISTRIBUTION_DEFAULT = "experimental"

def parse_dch(dch_str, *args):
    return subprocess.run(
        ["dpkg-parsechangelog", "-l-", "-c1"] + list(args),
        input=dch_str,
        check=True,
        universal_newlines=True,
        stdout=subprocess.PIPE,
        ).stdout.rstrip()

def read_dch(dch_str):
    dch = {}
    for i in ("Version", "Distribution", "Urgency", "Maintainer"):
        dch[i] = parse_dch(dch_str, "-S"+i)
    dch["Changes"] = "".join(parse_dch(dch_str, "-SChanges").splitlines(True)[3:])
    return dch

def is_dch(path):
    return (basename(path) == 'changelog'
        and basename(dirname(path)) == 'debian'
        and dirname(dirname(dirname(path))) == '')

def hunk_lines_to_str(hunk_lines):
    return "".join(map(lambda x: str(x)[1:], hunk_lines))

def read_dch_patch(dch_patch):
    if len(dch_patch) > 1:
        raise ValueError("don't know how to deal with d/changelog patch that has more than one hunk")
    hunk = dch_patch[0]
    source_str = hunk_lines_to_str(hunk.source_lines()) + DCH_DUMMY_TAIL
    target_str = hunk_lines_to_str(hunk.target_lines())
    # here we assume the debdiff has enough context to see the previous version
    # this should be true all the time in practice
    source_version = parse_dch(source_str, "-SVersion")
    target = read_dch(target_str)
    return source_version, target

def apply_dch_patch(source_file, current, patch_name, old_version, target, dry_run):
    # Do not change this text, unless you also add logic to detect markers from
    # previously-released versions.
    marker = "Patch %s applied by debpatch(1)." % patch_name
    if marker in current["Changes"]:
        logging.info("patch %s already applied to d/changelog", patch_name)
        return target["Version"]

    dch_args = []
    dch_env = dict(os.environ)

    if target["Distribution"] == "UNRELEASED":
        # UNRELEASED causes hard-to-reason-about behaviours in dch, let's avoid that
        newdist = current["Distribution"] if current["Distribution"] != "UNRELEASED" else DISTRIBUTION_DEFAULT
        logging.info("using distribution '%s' instead of 'UNRELEASED'", newdist)
        target["Distribution"] = newdist

    if not old_version or not target["Version"].startswith(old_version):
        logging.warn("don't know how to reapply version-change %s to %s" %
            (old_version, target["Version"]))
        version = subprocess.check_output(["sh", "-c",
            "EDITOR=cat dch -n 2>/dev/null | dpkg-parsechangelog -l- -SVersion"
            ]).decode("utf-8").rstrip()
        logging.warn("using version %s based on `dch -n`; feel free to make me smarter", version)
    else:
        version_suffix = target["Version"][len(old_version):]
        version = current["Version"] + version_suffix
        logging.info("using version %s based on suffix %s", version, version_suffix)

    if dry_run:
        return version

    dch_args += ["-v", version]
    dch_args += ["--force-distribution", "-D", target["Distribution"]]
    dch_args += ["-u", target["Urgency"]]
    if "Maintainer" in target:
        dch_env["DEBEMAIL"] = target["Maintainer"]
        del dch_env["DEBFULLNAME"]

    changes = target["Changes"]
    if changes.lstrip().startswith("["):
        changes = "\n" + changes

    token = "DEBPATCH PLACEHOLDER %s DELETEME" % random.randint(0, 2**64)
    shutil.copy(source_file, source_file + ".debpatch.bak")
    try:
        C(["dch", "-c", source_file] + dch_args + [token])
        C(["dch", "-c", source_file, "-a", marker], )
        C(["sed", "-e", "/%s/c\\\n%s" % (token, changes.replace("\n", "\\\n")), "-i", source_file])
    except:
        os.rename(source_file, source_file + ".debpatch.err")
        logging.warn("failed to patch %s", source_file)
        logging.warn("half-applied changes in %s", source_file + ".debpatch.err")
        logging.warn("current working directory is %s", os.getcwd())
        os.rename(source_file + ".debpatch.bak", source_file)
        raise
    else:
        os.unlink(source_file + ".debpatch.bak")

def call_patch(patch_str, *args, check=True, **kwargs):
    return subprocess.run(
        ["patch", "-p1"] + list(args),
        input=patch_str,
        universal_newlines=True,
        check=check,
        **kwargs)

def check_patch(patch_str, *args, **kwargs):
    return call_patch(patch_str,
        "--dry-run", "-f", "--silent",
        *args,
        check=False,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        **kwargs).returncode == 0

def apply_patch_str(patch_name, patch_str):
    if check_patch(patch_str, "-N"):
        call_patch(patch_str)
        logging.info("patch %s applies!", patch_name)
    elif check_patch(patch_str, "-R"):
        logging.info("patch %s already applied", patch_name)
    else:
        call_patch(patch_str, "--dry-run")
        raise ValueError("patch %s doesn't apply!", patch_name)

def debpatch(patch, patch_name, args):
    if len(patch_name) > 60:
        # this messes with our dch "already applied" logic detection, sorry
        raise ValueError("pick a shorter patch name; sorry")

    # don't change anything if...
    dry_run = args.target_version

    changelog = list(filter(lambda x: is_dch(x.path), patch))
    if not changelog:
        logging.info("no debian/changelog in patch: %s" % args.patch_file)
        old_version = None
        target = {
            "Version": None,
            "Distribution": DISTRIBUTION_DEFAULT,
            "Urgency": "low",
            "Changes": "  * Rebase patch %s." % patch_name,
        }
    elif len(changelog) > 1:
        raise ValueError("more than one debian/changelog patch???")
    else:
        patch.remove(changelog[0])
        old_version, target = read_dch_patch(changelog[0])

    if args.source_version:
        if old_version:
            print(old_version)
        return

    if not dry_run:
        apply_patch_str(patch_name, str(patch))

    # only apply d/changelog patch if the rest of the patch applied
    with open(args.changelog) as fp:
        current = read_dch(fp.read())
    new_version = apply_dch_patch(args.changelog, current, patch_name, old_version, target, dry_run)
    if args.target_version:
        print(new_version)
        return

    if args.repl:
        import code
        code.interact(local=locals())

def main(args):
    parser = argparse.ArgumentParser(
        description='Apply a debdiff to a Debian source package')
    parser.add_argument('-v', '--verbose', action="store_true",
        help='Output more information')
    parser.add_argument('-c', '--changelog', default='debian/changelog',
        help='Path to debian/changelog; default: %(default)s')
    parser.add_argument('--repl', action="store_true",
        help="Run the python REPL after processing.")
    parser.add_argument('--source-version', action="store_true",
        help="Don't apply the patch; instead print out the version of the "
        "package that it is supposed to be applied to, or nothing if the patch "
        "does not specify a source version.")
    parser.add_argument('--target-version', action="store_true",
        help="Don't apply the patch; instead print out the new version of the "
        "package debpatch(1) would generate, when the patch is applied to the "
        "the given target package, as specified by the other arguments.")
    parser.add_argument('orig_dsc_or_dir', nargs='?', default=".",
        help="Target to apply the patch to. This can either be an unpacked "
        "source tree, or a .dsc file. In the former case, the directory is "
        "modified in-place; in the latter case, a second .dsc is created. "
        "Default: %(default)s")
    parser.add_argument('patch_file', nargs='?', default="/dev/stdin",
        help="Patch file to apply, in the format output by debdiff(1). "
        "Default: %(default)s")
    group1 = parser.add_argument_group('Options for .dsc patch targets')
    group1.add_argument('--no-clean', action="store_true",
        help="Don't clean temporary directories after a failure, so you can "
        "examine what failed.")
    group1.add_argument('--quilt-refresh', action="store_true",
        help="If the building of the new source package fails, try to refresh "
        "patches using quilt(1) then try building it again.")
    group1.add_argument('-d', '--directory', default=None,
        help="Extract the .dsc into this directory, which won't be cleaned up "
        "after debpatch(1) exits. If not given, then it will be extracted to a "
        "temporary directory.")
    args = parser.parse_args(args)
    #print(args)

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    with open(args.patch_file, 'rb') as fp:
        data = fp.read()
    for enc in TRY_ENCODINGS:
        try:
            patch = unidiff.PatchSet(data.splitlines(keepends=True), encoding=enc)
            break
        except:
            if enc == TRY_ENCODINGS[-1]:
                raise
            else:
                continue

    patch_name = '%s:%s' % (
        basename(args.patch_file),
        hashlib.sha256(data).hexdigest()[:20 if args.patch_file == '/dev/stdin' else 8])
    quiet = args.source_version or args.target_version
    dry_run = args.source_version or args.target_version
    stdout = subprocess.DEVNULL if quiet else None # user can redirect stderr themselves

    # change directory before applying patches
    if os.path.isdir(args.orig_dsc_or_dir):
        os.chdir(args.orig_dsc_or_dir)
        debpatch(patch, patch_name, args)
    elif os.path.isfile(args.orig_dsc_or_dir):
        parts = os.path.splitext(os.path.basename(args.orig_dsc_or_dir))
        if parts[1] != ".dsc":
            raise ValueError("unrecognised patch target: %s" % args.orig_dsc_or_dir)
        extractdir = args.directory if args.directory else tempfile.mkdtemp()
        if not os.path.isdir(extractdir):
            os.makedirs(extractdir)
        try:
            builddir = os.path.join(extractdir, parts[0]) # dpkg-source doesn't like existing dirs
            C(["dpkg-source", "-x", "--skip-patches", args.orig_dsc_or_dir, builddir], stdout=stdout)
            origdir = os.getcwd()
            os.chdir(builddir)
            debpatch(patch, patch_name, args)
            if dry_run:
                return
            os.chdir(origdir)
            try:
                C(["dpkg-source", "-b", builddir])
            except subprocess.CalledProcessError:
                if args.quilt_refresh:
                    C(["sh", "-c", """
set -ex
export QUILT_PATCHES=debian/patches
while quilt push; do quilt refresh; done
"""
                        ], cwd=builddir)
                    C(["dpkg-source", "-b", builddir])
                else:
                    raise
        finally:
            cleandir = builddir if args.directory else extractdir
            if args.no_clean:
                logging.warn("you should clean up temp files in %s", cleandir)
            else:
                shutil.rmtree(cleandir)

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
