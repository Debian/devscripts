#!/usr/bin/python3
#
# Copyright (C) 2010-2018, Benjamin Drung <bdrung@debian.org>
#               2010, Stefano Rivera <stefanor@ubuntu.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import argparse
import glob
import operator
import os
import re
import sys

from devscripts.control import Control

CONTROL_LIST_FIELDS = (
    "Breaks",
    "Build-Conflicts",
    "Build-Conflicts-Arch",
    "Build-Conflicts-Indep",
    "Build-Depends",
    "Build-Depends-Arch",
    "Build-Depends-Indep",
    "Built-Using",
    "Conflicts",
    "Depends",
    "Enhances",
    "Pre-Depends",
    "Provides",
    "Recommends",
    "Replaces",
    "Suggests",
    "Xb-Npp-MimeType",
)

SUPPORTED_FILES = (
    "clean",
    "control",
    "control*.in",
    "copyright",
    "copyright.in",
    "dirs",
    "*.dirs",
    "docs",
    "*.docs",
    "examples",
    "*.examples",
    "info",
    "*.info",
    "install",
    "*.install",
    "links",
    "*.links",
    "mainscript",
    "*.maintscript",
    "manpages",
    "*.manpages",
)


class WrapAndSortControl(Control):
    def __init__(self, filename, args):
        super().__init__(filename)
        self.opts = args

    def wrap_and_sort(self):
        for paragraph in self.paragraphs:
            for field in CONTROL_LIST_FIELDS:
                if field in paragraph:
                    self._wrap_field(paragraph, field, True)
            if "Uploaders" in paragraph:
                self._wrap_field(paragraph, "Uploaders", False)
            if "Architecture" in paragraph:
                archs = set(paragraph["Architecture"].split())
                # Sort, with wildcard entries (such as linux-any) first:
                archs = sorted(archs, key=lambda x: ("any" not in x, x))
                paragraph["Architecture"] = " ".join(archs)

        if self.opts.sort_binary_packages:
            first = self.paragraphs[:1 + int(self.opts.keep_first)]
            sortable = self.paragraphs[1 + int(self.opts.keep_first):]
            sort_key = operator.itemgetter("Package")
            self.paragraphs = first + sorted(sortable, key=sort_key)

    def _wrap_field(self, control, entry, sort):
        # An empty element is not explicitly disallowed by Policy but known to
        # break QA tools, so remove any
        packages = [x.strip() for x in control[entry].split(",") if x.strip()]

        # Sanitize alternative packages. E.g. "a|b  |c" -> "a | b | c"
        packages = [" | ".join([x.strip() for x in p.split("|")]) for p in packages]

        if sort:
            # Remove duplicate entries
            packages = set(packages)
            packages = sort_list(packages)

        length = len(entry) + sum([2 + len(package) for package in packages])
        if self.opts.wrap_always or length > self.opts.max_line_length:
            indentation = " "
            if not self.opts.short_indent:
                indentation *= len(entry) + len(": ")
            packages_with_indention = [indentation + x for x in packages]
            packages_with_indention = ",\n".join(packages_with_indention)
            if self.opts.trailing_comma:
                packages_with_indention += ','
            if self.opts.short_indent:
                control[entry] = "\n" + packages_with_indention
            else:
                control[entry] = packages_with_indention.strip()
        else:
            control[entry] = ", ".join(packages)


class Install(object):
    def __init__(self, filename, args):
        self.content = None
        self.filename = None
        self.opts = args
        self.open(filename)

    def open(self, filename):
        assert os.path.isfile(filename), "%s does not exist." % (filename)
        self.filename = filename
        self.content = [l.strip() for l in open(filename).readlines() if l.strip()]

    def save(self, filename=None):
        if filename:
            self.filename = filename
        install_file = open(self.filename, "w")
        install_file.write("\n".join(self.content) + "\n")
        install_file.close()

    def sort(self):
        self.content = sorted(self.content)


def remove_trailing_whitespaces(filename):
    assert os.path.isfile(filename), "%s does not exist." % (filename)
    content = open(filename).read()
    if not content:
        return
    content = content.rstrip() + "\n"
    lines = content.split("\n")
    lines = [l.rstrip() for l in lines]
    new_content = "\n".join(lines)
    with open(filename, "w") as _file:
        _file.write(new_content)


def sort_list(unsorted_list):
    packages = [x for x in unsorted_list if re.match("[a-z0-9]", x)]
    special = [x for x in unsorted_list if not re.match("[a-z0-9]", x)]
    return sorted(packages) + sorted(special)


def wrap_and_sort(args):
    control_files = [f for f in args.files if re.search("/control[^/]*$", f)]
    for control_file in control_files:
        if args.verbose:
            print(control_file)
        control = WrapAndSortControl(control_file, args)
        if args.cleanup:
            control.strip_trailing_spaces()
        control.wrap_and_sort()
        control.save()

    copyright_files = [f for f in args.files
                       if re.search("/copyright[^/]*$", f)]
    for copyright_file in copyright_files:
        if args.verbose:
            print(copyright_file)
        remove_trailing_whitespaces(copyright_file)

    pattern = "(dirs|docs|examples|info|install|links|maintscript|manpages)$"
    install_files = [f for f in args.files if re.search(pattern, f)]
    for install_file in sorted(install_files):
        if args.verbose:
            print(install_file)
        install = Install(install_file, args)
        install.sort()
        install.save()


def get_files(debian_directory):
    """Returns a list of files that should be wrapped and sorted."""
    files = []
    for supported_files in SUPPORTED_FILES:
        file_pattern = os.path.join(debian_directory, supported_files)
        files.extend(file_name for file_name in glob.glob(file_pattern)
                     if not os.access(file_name, os.X_OK))
    return files


def main():
    script_name = os.path.basename(sys.argv[0])
    epilog = "See %s(1) for more info." % (script_name)
    parser = argparse.ArgumentParser(epilog=epilog)

    parser.add_argument("-a", "--wrap-always", action="store_true", default=False,
                        help="wrap lists even if they do not exceed the line length limit")
    parser.add_argument("-s", "--short-indent", dest="short_indent",
                        help="only indent wrapped lines by one space (default is "
                             "in-line with the field name)",
                        action="store_true", default=False)
    parser.add_argument("-b", "--sort-binary-packages",
                        help="Sort binary package paragraphs by name",
                        dest="sort_binary_packages", action="store_true",
                        default=False)
    parser.add_argument("-k", "--keep-first",
                        help="When sorting binary package paragraphs, leave the "
                             "first one at the top. Unqualified debhelper "
                             "configuration files are applied to the first "
                             "package.",
                        dest="keep_first", action="store_true", default=False)
    parser.add_argument("-n", "--no-cleanup", help="don't cleanup whitespaces",
                        dest="cleanup", action="store_false", default=True)
    parser.add_argument("-t", "--trailing-comma", help="add trailing comma",
                        dest="trailing_comma", action="store_true",
                        default=False)
    parser.add_argument("-d", "--debian-directory", dest="debian_directory",
                        help="location of the 'debian' directory (default: ./debian)",
                        metavar="PATH", default="debian")
    parser.add_argument("-f", "--file", metavar="FILE",
                        dest="files", action="append", default=list(),
                        help="Wrap and sort only the specified file.")
    parser.add_argument("-v", "--verbose",
                        help="print all files that are touched",
                        dest="verbose", action="store_true", default=False)
    parser.add_argument("--max-line-length", type=int, default=79,
                        help="set maximum allowed line length before wrapping "
                             "(default: %(default)i)")

    args = parser.parse_args()

    if not os.path.isdir(args.debian_directory):
        parser.error('Debian directory not found, expecting "%s".' %
                     args.debian_directory)

    not_found = [f for f in args.files if not os.path.isfile(f)]
    if not_found:
        parser.error('Specified files not found: %s' % ", ".join(not_found))

    if not args.files:
        args.files = get_files(args.debian_directory)

    wrap_and_sort(args)


if __name__ == "__main__":
    main()
